import Foundation
import BinaryCodable

public enum NetscapeCookieJarError: Error {
    case lineShouldSkip
    case lineSkipped
}

public protocol NetscapeCookieJarConvertible {
    init(from cookieJar: NetscapeCookieJar)
}

public class NetscapeCookieJar: Codable, BinaryCodable, CookieJarConvertible, HTTPCookieJarExportable, EditThisCookieExportable, MiddleCookieJarExportable {
    
    public var cookies: [NetscapeCookie]
    
    enum CodingKeys: String, CodingKey {
        case cookies
    }
    
    public required init(from cookieJar: NetscapeCookieJar) {
        self.cookies = cookieJar.cookies.map({ NetscapeCookie(from: $0) })
    }
    
    public required init(from cookieJar: EditThisCookie) {
        self.cookies = cookieJar.map({ NetscapeCookie(from: $0) })
    }
    
    public required init(from cookieJar: BinaryCookieJar) {
        self.cookies = cookieJar.pages
            .flatMap({ $0.cookies })
            .map({ NetscapeCookie(from: $0) })
    }
    
    public required init(from cookieJar: HTTPCookieJar) {
        self.cookies = cookieJar.map({ NetscapeCookie(from: $0) })
    }
    
    public required init(from cookieJar: LWPCookieJar) {
        self.cookies = cookieJar.cookies.map({ NetscapeCookie(from: $0) })
    }
    
    public required init(from cookieJar: MiddleCookieJar) {
        self.cookies = cookieJar.map({ NetscapeCookie(from: $0) })
    }
    
    public func toHTTPCookieJar() -> HTTPCookieJar {
        return cookies.compactMap({ $0.toHTTPCookie() })
    }
    
    public func toEditThisCookie() -> EditThisCookie {
        return cookies.map({ EditThisCookieItem(from: $0) })
    }
    
    public func toMiddleCookieJar() -> MiddleCookieJar {
        return cookies.compactMap({ $0.toMiddleCookie() })
    }
    
    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.cookies = try container.decode([NetscapeCookie].self, forKey: .cookies)
    }
    
    public required init(from decoder: BinaryDecoder) throws {
        var container = decoder.container(maxLength: nil)
        
        var cookies: [NetscapeCookie] = []
        while !container.isAtEnd {
            do {
                if NetscapeCookieJar.skippedPrefixes.contains(Unicode.Scalar(try container.peek(length: 1).first!)) {
                    throw NetscapeCookieJarError.lineShouldSkip
                }
                var cookieContainer = container.nestedContainer(maxLength: nil)
                let cookie = try cookieContainer.decode(NetscapeCookie.self)
                cookies.append(cookie)
            } catch NetscapeCookieJarError.lineShouldSkip {
                _ = try? container.decodeString(encoding: .utf8, terminator: NetscapeCookieJar.newlineCharacter)
                continue
            } catch NetscapeCookieJarError.lineSkipped {
                continue
            }
        }
        
        if cookies.count == 0 {
            throw BinaryDecodingError.dataCorrupted(.init(debugDescription: "cookie not found"))
        }
        
        self.cookies = cookies
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(cookies, forKey: .cookies)
    }
    
    public func encode(to encoder: BinaryEncoder) throws {
        var container = encoder.container()
        
        try container.encode(sequence: NetscapeCookieJar.optionalHeader)
        try container.encode(cookies)
    }
    
    private static let optionalHeader = Data("""
# Netscape HTTP Cookie File
# https://curl.haxx.se/docs/http-cookies.html
# This file was generated by CookiesTool <https://github.com/Lessica/CookiesTool>! Edit at your own risk.


""".utf8)
    private static let skippedPrefixes = CharacterSet.whitespacesAndNewlines
    private static let newlineCharacter = "\n".utf8.first!
}

public protocol NetscapeCookieConvertible {
    init(from cookie: NetscapeCookie)
}

public class NetscapeCookie: Codable, BinaryCodable, CookieConvertible, HTTPCookieExportable, MiddleCookieExportable {
    
    public var isHTTPOnly: Bool = false
    public var domain: String!
    public var includeSubdomains: Bool = false
    public var path: String!
    public var isSecure: Bool = false
    public let expiration: Date
    public var name: String!
    public var value: String!
    
    enum CodingKeys: String, CodingKey {
        case isHTTPOnly, domain, includeSubdomains, path, isSecure, expiration, name, value
    }
    
    public required init(from cookie: NetscapeCookie) {
        isHTTPOnly = cookie.isHTTPOnly
        domain = cookie.domain
        includeSubdomains = cookie.includeSubdomains
        path = cookie.path
        isSecure = cookie.isSecure
        expiration = cookie.expiration
        name = cookie.name
        value = cookie.value
    }
    
    public required init(from cookie: BinaryCookie) {
        isHTTPOnly = cookie.flags.contains(.isHTTPOnly)
        domain = cookie.url
        includeSubdomains = cookie.url.hasPrefix(".")
        path = cookie.path
        isSecure = cookie.flags.contains(.isSecure)
        expiration = cookie.expiration
        name = cookie.name
        value = cookie.value
    }
    
    public required init(from cookie: EditThisCookieItem) {
        isHTTPOnly = cookie.httpOnly
        domain = cookie.domain
        includeSubdomains = cookie.domain.hasPrefix(".")
        path = cookie.path
        isSecure = cookie.secure
        expiration = cookie.expirationDate ?? Date.distantFuture
        name = cookie.name
        value = cookie.value
    }
    
    public required init(from cookie: LWPCookie) {
        isHTTPOnly = false
        domain = cookie.domain
        includeSubdomains = cookie.domain.hasPrefix(".")
        path = cookie.path
        isSecure = cookie.secure
        expiration = cookie.expires
        name = cookie.key
        value = cookie.val
    }
    
    public required init(from cookie: HTTPCookie) {
        isHTTPOnly = cookie.isHTTPOnly
        domain = cookie.domain
        includeSubdomains = cookie.domain.hasPrefix(".")
        path = cookie.path
        isSecure = cookie.isSecure
        expiration = cookie.expiresDate ?? Date.distantFuture
        name = cookie.name
        value = cookie.value
    }
    
    public required init(from cookie: MiddleCookie) {
        if let httpOnly = cookie[.httpOnly] as? Bool {
            self.isHTTPOnly = httpOnly
        } else if let httpOnly = cookie[.httpOnly] as? String {
            self.isHTTPOnly = Bool(httpOnly) ?? false
        } else {
            self.isHTTPOnly = false
        }
        self.domain = (cookie[.domain] as! String)
        self.includeSubdomains = (cookie[.domain] as! String).hasPrefix(".")
        self.path = (cookie[.path] as? String) ?? "/"
        if let secure = cookie[.secure] as? Bool {
            self.isSecure = secure
        } else if let secure = cookie[.secure] as? String {
            self.isSecure = Bool(secure) ?? false
        } else {
            self.isSecure = false
        }
        if let expirationDate = cookie[.expires] as? Date {
            self.expiration = expirationDate
        } else if let expirationDate = cookie[.expires] as? String, let expInterval = TimeInterval(expirationDate) {
            self.expiration = Date(timeIntervalSince1970: expInterval)
        } else {
            self.expiration = Date.distantFuture
        }
        self.name = (cookie[.name] as! String)
        self.value = (cookie[.value] as! String)
    }
    
    public func toHTTPCookie() -> HTTPCookie? {
        return HTTPCookie(properties: toMiddleCookie()!)
    }
    
    public func toMiddleCookie() -> MiddleCookie? {
        return [
            .domain: domain!,
            .expires: expiration,
            .name: name!,
            .path: path!,
            .secure: String(describing: isSecure),
            .value: value!,
            .version: "0",
        ]
    }
    
    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        isHTTPOnly = try container.decode(Bool.self, forKey: .isHTTPOnly)
        domain = try container.decode(String.self, forKey: .domain)
        includeSubdomains = try container.decode(Bool.self, forKey: .includeSubdomains)
        path = try container.decode(String.self, forKey: .path)
        isSecure = try container.decode(Bool.self, forKey: .isSecure)
        expiration = Date(timeIntervalSince1970: try container.decode(TimeInterval.self, forKey: .expiration))
        name = try container.decode(String.self, forKey: .name)
        value = try container.decode(String.self, forKey: .value)
    }
    
    public required init(from decoder: BinaryDecoder) throws {
        var container = decoder.container(maxLength: nil)
        
        let prefixData = try container.peek(length: NetscapeCookie.httpOnlyPrefix.count)
        if prefixData == NetscapeCookie.httpOnlyPrefix {
            _ = try? container.decode(length: prefixData.count)
            isHTTPOnly = true
        }
        else if prefixData.prefix(1) == NetscapeCookie.skipPrefix {
            _ = try? container.decodeString(encoding: .utf8, terminator: NetscapeCookie.newlineCharacter)
            throw NetscapeCookieJarError.lineSkipped
        }
        
        domain = try container.decodeString(encoding: .utf8, terminator: NetscapeCookie.tabCharacter)
        includeSubdomains = (try container.decodeString(encoding: .utf8, terminator: NetscapeCookie.tabCharacter).uppercased() == "TRUE")
        path = try container.decodeString(encoding: .utf8, terminator: NetscapeCookie.tabCharacter)
        isSecure = (try container.decodeString(encoding: .utf8, terminator: NetscapeCookie.tabCharacter).uppercased() == "TRUE")
        expiration = Date(timeIntervalSince1970: TimeInterval(try container.decodeString(encoding: .utf8, terminator: NetscapeCookie.tabCharacter)) ?? 0.0)
        name = try container.decodeString(encoding: .utf8, terminator: NetscapeCookie.tabCharacter)
        value = try container.decodeString(encoding: .utf8, terminator: NetscapeCookie.newlineCharacter)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(isHTTPOnly, forKey: .isHTTPOnly)
        try container.encode(domain, forKey: .domain)
        try container.encode(includeSubdomains, forKey: .includeSubdomains)
        try container.encode(path, forKey: .path)
        try container.encode(isSecure, forKey: .isSecure)
        try container.encode(expiration.timeIntervalSince1970, forKey: .expiration)
        try container.encode(name, forKey: .name)
        try container.encode(value, forKey: .value)
    }
    
    public func encode(to encoder: BinaryEncoder) throws {
        var container = encoder.container()
        
        if isHTTPOnly {
            try container.encode(sequence: NetscapeCookie.httpOnlyPrefix)
        }
        try container.encode(domain, encoding: .utf8, terminator: NetscapeCookie.tabCharacter)
        try container.encode(includeSubdomains ? "TRUE" : "FALSE", encoding: .utf8, terminator: NetscapeCookie.tabCharacter)
        try container.encode(path, encoding: .utf8, terminator: NetscapeCookie.tabCharacter)
        try container.encode(isSecure ? "TRUE" : "FALSE", encoding: .utf8, terminator: NetscapeCookie.tabCharacter)
        try container.encode(String(Int(expiration.timeIntervalSince1970)), encoding: .utf8, terminator: NetscapeCookie.tabCharacter)
        try container.encode(name, encoding: .utf8, terminator: NetscapeCookie.tabCharacter)
        try container.encode(value, encoding: .utf8, terminator: NetscapeCookie.newlineCharacter)
    }
    
    private static let tabCharacter = "\t".utf8.first!
    private static let newlineCharacter = "\n".utf8.first!
    private static let skipPrefix = Data("#".utf8)
    private static let httpOnlyPrefix = Data("#HttpOnly_".utf8)
}
